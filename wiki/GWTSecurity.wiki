#summary GWT client and server security implementation
#labels GWTSecurity,SpringSecurity,SessionHandling,Security

= Introduction =

If you are trying to integrate security with your GWT application, you probably know that there is no consistent solution which you can use in your application. There are more issues why is not well solved issue:
 * session handling using RPC calls
 * security integration on client side (spring-security subset classes emulation on GWT module)
 * security integration on server side (handling RPC calls, exception propagation to the client, integration with spring-security, ...)

This is pretty much stuff to be solved in one reusable project and the name of the project is *acris-security*. Yes, If you believe or not, you can easily use client security annotation like this
{{{
@Secured("ROLE_NAME")
public class MyPanel extends LayoutContainer implements ISecuredPanel {

       @Secured("ROLE_NAME")
       //this field will be visible only to authorized users
       protected TextField<String> textField;
...
}
}}}

and server side security annotations on your secured services like this:
{{{
@Secured("USER_MAINTENANCE_ROLE_PERMISSION_CREATE")
//this method can be executed only by authorized users
public void addUser(User user) {
    ...
}
}}}

= Domain level security - ACL =

 * ACL (Access control list) defines security on domain level (persistent entities)
 * Specify permissions to the concrete instance of secured object to the specific user
   ** for example tell that user with username "admin" has read permissions to the content object with id 36
   ** user admin now can read content object with id 36 but he cannot change or delete this object
   ** user admin cannot read and modify content object with id 37 because he has no ACL entries (ACE) to this object
 * possible permissions: READ (user can view the object), WRITE (user can modify existing instance), DELETE (user can delete existing instance), CREATE (user can create a new instances of the object)
 * in our example:
   ** is user admin stored in ACLSecuredIdentity table (with sid=admin and principal=true and autogenerated id)
   ** content (his qualified classname - sk.seges.domain.Content) is stored in ACLClass table (with autogenerated id)
   ** instance 36 of object content is stored in ACLObjectIdentity table (with object_id_identity=36, object_id_class referenced to autogenerated id to the table ACLClass, owner_sid is referenced to atuogenerated id in the table ACLSecuredIdentit and autogenerated id)

Let's see the class diagram with the detailed description:

[http://acris.googlecode.com/svn/wiki/images/security_acl.png]

===== ACL security check annotations =====

====== BeforeAclCheck annotation ======

* used for checking ACL permissions before executing the method with specified parameters.
{{{
@BeforeAclCheck(Permission.VIEW)
@Secured(RolePermissions.USER_MAINTENANCE_ROLE_PERMISSION_READ)
public void readMethod(AbstractSecuredObject securedObject) {
}
}}}

* In previous example, we are checking if the current logged user has sufficient (VIEW) permissions to the securedObject, which is an argument in secured method - readMethod
* If the user has sufficient permission method is executed
* If the user has not sufficient permission AccessDeniedException is thrown

====== AfterAclCheck annotation ======

* used for checking ACL permission after method execution
* checking return value of the method (single object or list of objects)

{{{
@AfterAclCheck
@Secured(RolePermissions.USER_MAINTENANCE_ROLE_PERMISSION_WRITE)
public List<AbstractSecuredObject> getListMethod(List<AbstractSecuredObject> securedObjects) {
	return securedObjects;
}
}}}

* In previous example we are checking return value of the getListMethod
* If user has sufficient permission for return objects than nothing happends :)
* Problem (for the logged user) is when user has not sufficient permission for objects, then:
  ** not permitted objects are filtered from result list (an empty list can be in result)
  ** AccessDeniedException is thrown in case of single object return value
{{{
@AfterAclCheck
@Secured(RolePermissions.USER_MAINTENANCE_ROLE_PERMISSION_WRITE)
public AbstractSecuredObject getMethod(AbstractSecuredObject securedObject) {
	return securedObject;
}
}}}

[http://acris.googlecode.com/svn/wiki/images/security_flow.png]

= Integration steps on client side =
(these steps are assuming that you have separated client&server architecture, if not than integration is little bit earlier, so we are covering the more complex scenario)

 # Add dependency to the acris-security project on your GWT application (into pom.xml)
{{{
<dependency>
	<groupId>sk.seges.acris</groupId>
	<artifactId>acris-security</artifactId>
</dependency>
<dependency>
	<groupId>sk.seges.acris</groupId>
	<artifactId>acris-security</artifactId>
	<classifier>sources</classifier>
</dependency>
}}}
 # Add GWT inherit into your .gwt.xml module file
{{{
<inherits name='sk.seges.acris.Security' />
}}}

= Session handling =

TODO

= Integration steps on server side =
 # Add session handling filter and listener into your web.xml on your server side
{{{
<filter>
	<filter-name>SessionFilter</filter-name>
	<filter-class>sk.seges.acris.security.server.SessionRemoteServiceFilter</filter-class>
</filter>
<filter-mapping>
	<filter-name>SessionFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>

<listener>
	<listener-class>sk.seges.acris.security.server.SessionHandlerListener</listener-class>
</listener>
}}}
 # Add spring resources into your application context configuration 
{{{
<jee:jndi-lookup id="dataSource" jndi-name="jdbc/acris" resource-ref="true"/>

<import resource="classpath:sk/seges/acris/security/server/security-config.xml" />
<import resource="classpath:sk/seges/acris/security/server/security-acl-config.xml" />
<import resource="classpath:sk/seges/acris/security/server/security-config-object-definition.xml" />
}}}