#summary Best GWT practices using MVP pattern and acris

= History =

When Google starts creating a new project for translating Java code into !JavaScript I was little bit sceptic. I've always knew that Google has very inovative approaches for solving the problems and they are still comming with a something epochal, but this goal was something different. Something that I wasn't fully identified with. I thought that !JavaScript and Java principles were so different that is not possible to create working port from one language to another at least for:
 * *threads* - how they will handle java multithread code in a single thread !JavaScript?
 * *filesystem* - almost whole java is tightly bound to *io* package which is not possible to use in the javascript
 * *reflection* - how they will use reflection (in a static !JavaScript) which is the most used technique in each bigger java framework?
This were only few ideas that comes into my mind and there is for sure a lot of more. But the time was moving and framework gets bigger and bigger and then I just wanted to try it if is already doing what Google promises.

It has to be a *rocket sience* to achieve translating java language into javascript - _I thought_ - but it will be a huge step forward for web 2.0 development (and also a wet and unspoken dream of each java developer). I've just wanted to be a part of this and started with first experiments with *GWT*. Year 2008 was written and GWT actual version was 1.4 and after short time I was completly addicted to Google Web Toolkit. Any other web platform seem to me as a non effective way of developing the web application (of course there exists many other perfect platforms which I was using before - mostly JSF & !IceFaces - but GWT completly fits my needs and the way of developing with GWT was completly natural for me).

Three years of development with GWT in a daily basis are gone and there are few big applications in a production, created by me and by the team I was part of. After 3 years it brings fruits to me and it's time to collect the fruits in a form of the best practices, which can be used by every Google Web Toolkit developer.

= Best practices =

OK, stop talking, just tell us the best practices so we can decide if they are usefull or not. 
In a short answer I have to say that I will completly follow up the principles proposed by *Ray Ryan* on *Google I/O 2009* and add something new to his proposals - and whats more, I have and working examples for you, not only the theory, so do no hesitate to start with them.

Just to sum up what Ryan was saying:
 * use *MVP* (*Model-View-Presenter*) pattern for preciselly spliting your code into three parts (data which are going to be displayed - *model* - forms and the screens with the UI widgets - *view* - and the logic somewhere between them - *presenter*)
 * use *event bus* in order to to interconnect these components and as a communication channel between presenters.
 * use *command pattern* and *dispatch service* as midlayer between client and server 
 * use *dependency injection* for loose coupling between your presenters and application parts
You probably know the diagrams presented by Ray identifying the process of loosely coupled elements. Looks cool, isn't it? :) Yes, of course, in a theory, but what about the reality?

[http://acris.googlecode.com/svn/wiki/images/mvp_coupling_small.png]

I dig into the MVP pattern paradigm and found few implementations for Google Web Toolkit. I'm not going to discuss here which MVP implementation is the best ([http://code.google.com/p/mvp4g/ mvp4g], [http://code.google.com/p/gwt-presenter/ gwt-presenter] or [http://code.google.com/p/gwt-platform/ gwt-platform]) this was well done by [http://borglin.net/gwt-project/?page_id=10 Andreas Borglin pages] and for my projects and for the presentation purposes I've choose the [http://code.google.com/p/gwt-platform/ gwt-platform] created by Philippe Beaudoin and  Christian Goudreau (thank you guys for the great work on this project). Note that I'm not saying that other MVP implementations are bad and you can choose another one if you one, it's still the MVP and this article is about the additional value of the MVP, so the concrete implementation really does not matter.

= So, how is the reality looks like? =

Let's firstly take a look on MVP pattern.
[http://acris.googlecode.com/svn/wiki/images/mvp_small.png]

Core of the each application is the model which represents application specific domain data and differs between the applications. But there are some parts of the domain area which you can find in each bigger application. I think it's not surprise to you that I'm talking about *users*, so I will explain you the model part of the MVP pattern on the users which I took from acris-security project.

[http://acris.googlecode.com/svn/wiki/images/user_model_lr_small.png]

The colors in the diagram are not there beacause it is fancy and super cool, but they helps us to identify which classes are used on *client (green)* part of the application, which are used on the *server (yellow)* side and which are the *common (red)* classes. As you can see from the diagram we will use the DTO's as lightweight version of the persistent entities, but both of the implements the same interface so we can all the time working the interfaces to have the code clear. So for example, service layer will works only with UserData interface:
{{{
@GenDispatch
public class PersistUser {
  @In(1) UserData user;
  @Out(1) UserData user;
}

public UserData persist(UserData entity);

}}}
Service method input is the transparently converted from !GenericUserDTO into !TwigGenericUser and return method is converted in oposite direction, from !TwigGenericUser into !GenericUserDTO automaticly using dozer. Ok, so far, so good - this is our domain model, now the question is how acris is extending the model?

== Model extension ==

Now if you are many of your DTO's used in your client application, you probably want to:
 * display the data in UI :)
 * use beans binding as a inteligent solution for data propagation
 * validate data that comes from UI

The plan is fine, but there are some issues that should be solved to have all this tasks working:
 * your domain model is pretty dependend on your UI library, because for example SmartGWT can work with Record interface, ExtGWT (GXT) can work with !ModelData interface and etc. so you have to ensure that your model will implements this interfaces and that, whole application is highly dependend on your UI library, which is definitely bad idea. This is the reason for the *[http://code.google.com/p/acris/wiki/BeanWrappers bean wrappers]*, which wrapps your model classes and add the specific behaviour (like setAttribute method) to them in a *completly transparent* way. In this way you can achieve that your model will not be dependend on UI library and you can switch the UI library without touching your model classes.
 * probably you know great gwt-beansbinding library which allows you to use beans binding in GWT applications. If yes, then you will be maybe interested into [http://code.google.com/p/acris/wiki/BeansBinding acris-binding] which allows you the same binding using the annotations. Only problem with beansbinding is that you have to implement !HasPropertyChangeSupport interface in your model and properly fires the property change events. This complicates situation little bit because it's pretty hard to maintain such things (and the number of interfaces in your model is still growing) and on the other hand, they should be *generated* so it is not necessary to write them. Second reasond for [http://code.google.com/p/acris/wiki/BeanWrappers bean wrappers].
 * and the third reason consist in validation itself. Here comes into place next great project [http://code.google.com/p/gwt-validation/ gwt-validation] which requires to have implemented IValidatable interface in your model. It is still possible to do it manually or it should be done in a fully automatic and transparent way using the bean wrappers. 

So the bean wrappers wraps your model and added specific support to it, like ModelData, IValidation, HasPropertyChangeSupport, etc. This process is ilustrated on the following diagram in model column.

[http://acris.googlecode.com/svn/wiki/images/mvp_acris_model_small.png]

=== Creating bean wrapper ===

You have few possibilities how to create bean wrapper for your bean (model data class):
 * annotate your model class with @BeanWrapper annotation
{{{
@BeanWrapper
public class GenericUserDTO implements UserData {
...
}
}}}
 * implement marker interface !ITransferableObject or domain interface !IDomainObject
{{{
public class GenericUserDTO implements UserData, ITransferableObject {
...
}
}}}
 * create external configuration with all classes listed in getClasses method
{{{
public class CustomBeanWrapperConfiguration extends DefaultBeanWrapperConfiguration {
	@Override
	public ClassDescriptor[] getClasses() {
		return new ClassDescriptor[] {
				new ClassResourceDescriptor(GenericUserDTO.class)
		};
	}
}
}}} 
 and change override default configuration in META-INF/bean-wrapper.properties file:
{{{
configuration=sk.seges.acris.binding.jsr269.CustomBeanWrapperConfiguration
}}}

By fulfilling one the steps above you will see the bean wrapper interface in the target/gernerated interface.

{{{
UserData user = ...; //fetched user from service
ListGridRecord record = GWT.create(GenericUserDTOBeanWrapper.class)
}}}

== Presenter extension ==

[http://acris.googlecode.com/svn/wiki/images/mvp_acris_presenter_small.png]

Cancel support

== View extension ==

[http://acris.googlecode.com/svn/wiki/images/mvp_acris_view_small.png]

= Overall view =

[http://acris.googlecode.com/svn/wiki/images/mvp_acris_small.png]

[http://acris.googlecode.com/svn/wiki/images/acris_binding_small.png]

[http://acris.googlecode.com/svn/wiki/images/security_steps_small.png]

= Demo application =

[http://acris.googlecode.com/svn/wiki/images/mvp_usecase.png]

[http://acris.googlecode.com/svn/wiki/images/mvp_user_maint_small.png]

= Hosting on appengine =

= Migrating possibilities =

== Migrate to RDBMS system ==

== Migrate to different UI library ==