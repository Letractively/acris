#summary Selenium support with advanced configuration possibilities

*Strong advice: The ones who does not use/like maven - go away, this wiki page is not for you! Seriously.*

= Creating new project with selenium support =

*Ensure* that you use sesam-os-base-parent (version 1.1.4-SNAPSHOT or higher) as your parent project (__note: or another project that has sesam-os-base-parent as the parent project__)
{{{
<project>
	...
	<parent>
		<groupId>sk.seges.sesam</groupId>
		<artifactId>sesam-os-base-parent</artifactId>
		<version>1.1.4-SNAPSHOT</version>
		<relativePath/>
	</parent>
</project>
}}}

*Create* following files in the root directory (where is your pom.xml located):
 * .pap - this enables maven profile responsible for annotation processor (JSR269) plugins and dependencies, configure required plugins and dependencies
 * .selenium - this provides all dependencies to the selenium and configures reporting plugins

= Why annotation processors ? =

Because they are sexy and they rocks :-) ... no, seriously, because of the configuration that can be achieved in very simple way (annotation processors aren't the only way how to achieve this result, but annotation really fits to this situation). 
 * Default configurations for the test cases are held in one file - it's called SuiteRunner and it looks in the following way:
{{{
@SeleniumSuite
@Selenium (
		testURL = "http://localhost/",
		testURI = "web/test",
		browser = Browsers.FIREFOX
)
@Mail (
		host = "smtp.googlemail.com",
		mail = "test@example.com",
		password = "password",
		provider = Provider.IMAPS
)
@Credentials(username = "admin", password = "password")
@Report(screenshot = @Support(enabled = true))
public class SuiteRunner {}
}}}

 * When you create test case (for example LoginTestCase) and defines @SeleniumTest annotation (with specific SuiteRunner), all configurations are automatically inherited from the SuiteRunner - this allows you to define global settings in one single place.
{{{
@SeleniumTest(suiteRunner = SuiteRunner.class)
public class LoginTestCase extends AbstractSynapsoTest {
	
	@Override
	protected SuiteRunnerSettingsProvider getSettings() {
		return new LoginTestCaseConfiguration();
	}	
	
	@Test
	public void testLogin() {
             //...test body
        }
}
}}}

 * If you want to override global settings only in hte specific test, you can do it easily - using annotations
{{{
@Credentials(username = "new_user", password = "other_password")
@SeleniumTest(suiteRunner = SuiteRunner.class)
public class LoginTestCase extends AbstractSeleniumTest {
	
	@Override
	protected SuiteRunnerSettingsProvider getSettings() {
		return new LoginTestCaseConfiguration();
	}	
	
	@Test
	public void testLogin() {
             //...test body
        }
}
}}}
 * In that case, all parameters will be inherited from suite runner except the credentials.
 * If you want to redefine configurations without touching the code, nothing is easier - just use the java variable, like:
{{{
mvn test -Dtest.username=production_user -Dtest.password=secred_password
}}}
 * Now, parameters from the command line will be used
 * This allows you to handle situations like:
   ** run tests on different platforms just using different parameters (still without touching the code), like executing tests on firefox {{{ mvn test -Dtest.testBrowser=firefox }}} or executing tests on IE {{{ mvn test -Dtest.testBrowser=iexplore }}}
   ** run tests on the test environment with test user and also run non invazive tests on the production environemnt with production user just by changing users from command line

== Default configurations ==

=== @Selenium ===

|| *Name* || *Description* || *Command line parameter* || *Default value* || *Required* ||
|| seleniumServer || Defines host name where the selenium server is located || test.seleniumHost || localhost || no ||
|| seleniumPort || Defines port name where the selenium server is located || test.seleniumPort || 4444 || no ||
|| seleniumRemote || Bindings connect to the remote server instance || test.testRemote || false || no ||
|| bromineServer || Defines host name where the bromine server is located || test.bromineHost || localhost || no ||
|| brominePort || Defines port name where the bromine server is located || test.brominePort || 8080 || no ||
|| bromine || Enables/disables support for bromine || test.bromineEnabled || false || no ||
|| testURL || Defines root URL of the testing site || test.testHost || _NON DEFINED_ || no ||
|| testURI || Defines relative URI of the testing home page || test.testUri || _NON DEFINED_ || no ||
|| browser || Defines browser the tests are executed with || test.testBrowser || FIREFOX || no ||

=== @Credentials ===

|| *Name* || *Description* || *Command line parameter* || *Default value* || *Required* ||
|| username || Username used to login to the system || test.username || _NON DEFINED_ || yes ||
|| password || Password used to login to the system || test.password || _NON DEFINED_ || yes ||

=== @Mail ==

|| *Name* || *Description* || *Command line parameter* || *Default value* || *Required* ||
|| mail || E-mail recepient settings || mail.address || _NON DEFINED_ || yes ||
|| password || E-mail password settings || mail.password || _NON DEFINED_ || yes ||
|| provider || E-mail provider || mail.provider || IMAP || no ||

=== @Report ===

|| *Name* || *Description* || *Command line parameter* || *Default value* || *Required* ||
|| screenshot.enabled || Screenshots enabled/disabled || report.screenshot.enabled || false || no ||
|| screenshot.directory || Output directory for the screenshots || report.screenshot.directory || _NON DEFINED_ || no ||
|| html.support.enabled || HTML report enabled/disabled || report.html.enabled || false || no ||
|| html.support.directory || Output directory for the HTML reports || report.html.directory || _NON DEFINED_ || no ||
|| html.support.templatePath || Defines path to the used template || report.html.template.path || _NON DEFINED_ || no ||

You can use all of these settings in each selenium (to be more precise: sesam-selenium) based project, but now comes the real advantage of the annotation processors - you can define own configuration settings using annotations and use them exactly in the same way as in the annotation described above! Maybe you don't understand what exaclty I'm talking (ehm writing :-) ) about so maybe the better way will the way with the examples:

Let's imagine that your application has openID/oauth based login and you want to define settings for that. So the firstly:
 * create a custom annotation for openID (or oauth)
{{{
public @interface OpenID {

	public enum Provider {
		GOOGLE("google"), ...;
		
		private String name;
		
		Provider(String name) {
			this.name = name;
		}
		
		@Override
		public String toString() {
			return name;
		}
	}

	@Parameter(name = "openid.used", description = "OpenID user")
	String user();

	
	@Parameter(name = "openid.pass", description = "OpenID password")
	String pass(); 
	
	@Parameter(name = "openid.provider", description = "OpenID provider")
	Provider provider() default Provider.GOOGLE;
}}}
 * define default settings in your SuiteRunner
{{{
@OpenID(user = "test@gmail.com", pass = "secred_pass", provider = Provider.GOOGLE)
public class SuiteRunner {}
}}}
 * you can access these settings in your test like
{{{
@SeleniumTest(suiteRunner = SuiteRunner.class)
public class OpenIDLoginTestCase extends AbstractSynapsoTest {
	@Override
	protected SuiteRunnerSettingsProvider getSettings() {
		return new OpenIDLoginTestCaseConfiguration();
	}

	@Test
	public void testLogin() {
                getSettings().getOpenID().getUser(); //... etc
        }
}
}}}
 * and you have all the possibilities that sesam-selenium offers, like: redefine default settings using {{{ -Dopen.user=production@gmail.com }}} or redefine global settings using annotation on the test case directly

= Maven integration =

|| *Task* || *Maven command* || *Decription* ||
|| *Eclipse integration* || mvn eclipse:clean eclipse:eclipse || This creates you eclipse based project with all settings required for annotation processor including the .factorypath, .org.eclipse.jdt.apt.core.prefs, .etc. *This command does not execute processors anymore!* ||
|| *Executing processors* || mvn processor:process processor:process-tests || This executes processor against the java sources and against the test sources ||
|| *Install selenium project* || mvn clean install -!DskipTests || Executes available annotation processors and installs JAR with all the test classes (with suffix -tests.jar) ||
|| *Executing tests* || mvn test || Execute tests with default configuration ||

= Eclipse integration =

You can run annotation processors also in the eclipse, eclipse:eclipse command prepares all required settings for the eclipse. You can check the settings in the project properties (alt + enter).

[http://acris.googlecode.com/svn/wiki/images/pap_eclipse_integration.png]

Annotation processor is executed immediately after the java source is saved and generated files are located in the target/generated directory (this should be part of the build path)

= Executing processors =

Processors are executed in 2 ways:
 * in the manual way using `mvn processor:process processor:process-tests` command or
 * in the automatic way using `mvn install` command

_Note: if do not want to execute processors against the test source just skip the processor:process-tests (= use only mvn processor:process) command or skip tests using -Dmaven.test.skip parameter._

= Install selenium project =

This allows you to reuse selenium common classes/tests in more project. Just install the project using `mvn clean install` _(or mvn clean install -!DskipTests if you don't want to execute tests during the installation)_ command and dependency to your new project:

{{{
<dependency>
	<groupId>__YOUR_GROUP_ID__</groupId>
	<artifactId>__YOUR_ARTIFACT_ID__</artifactId>
	<version>__VERSION__</version>
	<type>test-jar</type>
	<scope>test</scope>
</dependency>
}}}

= Executing tests =

Tests can be executed using `mvn test` command using default configuration listend in the SuiteRunner:

{{{
@SeleniumSuite
@SeleniumTestConfiguration(
		testURL = "http://example.com",
		testURI = "/selenium/test-site/",
		browser = Browsers.FIREFOX
)
@MailConfiguration(
		host = "smtp.example.com",
		mail = "secure@example.com",
		password = "secured_pass",
		provider = Provider.IMAPS
)
@ReportConfiguration(
		screenshotConfiguration = @ScreenshotConfiguration(
				produceScreenshots = true
		)
)
@Credentials (
		username = "secret_user",
		password = "secred_pass"
)
public class SuiteRunner extends SuiteRunnerConfiguration {

	public static void main(String[] args) throws Exception {
		new SuiteRunner().run();
	}
}
}}}

= Problems =

 * ~~APT maven plugin creates factory path entries with trailing whitespace~~ - this is problem only on linux environment (see reported issue) - [http://jira.codehaus.org/browse/MOJO-1609] - *SOLVED* with 1.0-alpha-5-SNAPSHOT version of the apt-maven-plugin
 * ~~Chicken-and-egg problem - if your project has compilation errors there is no easy way how to import project into the eclipse (because processors execution is part of the eclipse:eclipse goal and if it fails no eclipse project file is generated)~~ - *SOLVED* processors are no more bound to the generate-source (generate-test-source) phase therefore you can create eclipse project and run processors separatelly

== Sample project ==

In a 3 steps:
 # download sample project from [http://acris.googlecode.com/svn/sesam/branches/selenium/ SVN repository] 
 # download and run [http://maven.apache.org/ maven]
 # run command {{{ mvn test }}}

Eclipse configuration:
 # run command {{{ mvn eclipse:eclipse }}}
 # import project into the eclipse
 # run test as junit tests (4 easy steps described on images below)

[http://acris.googlecode.com/svn/wiki/images/selenium_1_eclipse.png]

[http://acris.googlecode.com/svn/wiki/images/selenium_2_import.png]

[http://acris.googlecode.com/svn/wiki/images/selenium_3_project.png]

[http://acris.googlecode.com/svn/wiki/images/selenium_4_final.png]